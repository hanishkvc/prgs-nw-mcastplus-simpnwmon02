##################################
Nw Testing/Data transfer logic
v20190116IST0653 - NEEDS UPDATING
HanishKVC, 19XY
##################################


Logic and Usage
#################


Overview
==========

This set of programs helps verify network performance as well as if required
transfer a file from server to multiple clients.


The Phases
------------

It consits of

Multicast based transfer logic

Multicast based stop logic

Unicast based Presence Info logic - to help clients and server come to know
about one another. Logic can work even if no communication during PI phase,
provided a known list of clients is provided before hand itself to the server.

Unicast based data / lost packet recovery logic - The server communicates with
the clients one by one and gets their list of lost packets, a small part at a
time, and helps them recover those by resending it thro unicast.


PI Phase
----------

If the PI phase fails to handshake between the server and the clients, the
server has the possibility of using a predefined list of clients to work with,
which is given to it, thro its context option.  While the client eitherway will
now respond to any server which requests it for list of lost packets.

Also if some known clients (passed to server logic thro its context argument)
don't send PIReq packets during PI phase, then the server will send mcast stop
commands to ensure that if any clients are still in mcast phase, then they can
come out of it and get into ucast recovery thro PIPhase+URPhase. After this
mcast stop retry the server logic will go back to waiting for PIReqs from known
clients (well as well as any new clients).


UnicastRecovery
-----------------
If a client stops responding in the middle of unicast error recovery or has
used up too many attempts and has still not fully recovered its lost packets,
then the server side logic will gracefully keep that client aside, and go to
the remaining clients. In turn at the end it will come back and check which
clients had been kept aside and then will try to help those clients recover
their lost packets.

Depending on the length of the content transfered, the server logic will decide
for how many times it should run thro the kept aside clients lists. Even after
that if there are clients which haven't fully recovered, the server will list
those clients and give up.

The logic will assume that upto a max of 8% to 10% packet losess could be there
and based on that decides how many attempts it should try wrt clients that keep
getting kept aside.

NOTE: If a client doesn't respond back to the server for upto N(1.5) minutes or
if it has not recovered all its lost packets even after handshaking with it for
512 times, then it is kept aside temporarily.

When the client communicates with server with URAckSeqNum, it not only gives a
small list of lost packet ranges to recover immidiately, but also in total how
many lost packet ranges (i.e iNodeCnt - the number of nodes in the list) are
there as well as inturn the total number of lost packets that are there to be
recovered (i.e iTotalFromRanges) at that given time in the client. These counts
also include the packets specified in the URAckSeqNum packet for immidiate
recovery.


LinkedListRanges
-----------------

The linked list will maintain reference to the
* start,
* end
as well as
* the last added node, in the list.
* the node immidiately before the last deleted (if any) node, in the list

It also maintains a count of total number of nodes and inturn the total/actual
number of values stored/represented in the list indirectly in the shortened
form of ranges.


NwGroups
---------

A given group of Server/ServerInstance and a set of clients assigned to that
Server/ServerInstance is given a unique NwGroup id/number. This helps assign a
unique set of ports for that nw test/transfer group.

By default this is 0. Which is good enough if only 1 nw test/transfer is used.

However if multiple nw tests/transfers require to be run parallely, then each
such group of server+clients should be given unique NwGroup Ids.

This also allows a single machine to run multiple instances of server or
multiple instances of client logic if required.


Client
==========

The client side logic is implemented in a single program.

./simpnwmon02 --maddr 230.0.0.1 --local 0 127.0.0.1 --file /dev/null --bcast 127.0.0.255 --nwgroup 2 --contextbase /tmp/newnow --context /tmp/whatelse.lostpackets.quit --runmodes 7


the Arguments
--------------

The client side simpnwmon02 program has the following command line arguments

./simpnwmon02
Mandatory arguments
--maddr mcast_ip --local local_nwif_index local_nwif_ip --file data_file --bcast nw_bcast_ip
Optional arguments
[--contextbase pathANDbasename_forcontext2save --context context2load_ifany --nwgroup id --runmodes runmodes]

the local_nwif means the ethernet or wifi interface which connects to the
network on which we want to run the test/data transfer logic.

the local_nwif_index is the index assigned by linux kernel for the used network
interface. It can be got by using ip addr and looking at the index number
specified by it. i.e if it is the 1st nw interface or .... Nth network
interface for which address details are provided by ip addr command.

the local_nwif_ip is the ip address assigned to the network interface which we
want to use.

The local_nwif_index and local_nwif_ip are used as part of the multicast join
using setsockoption. Ideally one is required to provide only one of these two
values.

If local_nwif_index is not being explicitly specified, then pass 0 for it.

If local_nwif_ip is not explicitly specified, then pass 0.0.0.0 for it.

mcast_ip is the multicast group ip address on which to listen for data / test
packets.

data_file is the file into which recieved data should be saved.

nw_bcast_ip is the network broadcast address into which PIReq packets should be
sent.

context2load_ifany is a optional parameter. This is required to be given, if
one wants the program to resume a previously broken in ucast recovery phase
transfer. Ideally It should be the file into which the program had saved the
context, when it was force exited previously by sending a SIGINT (ctrl+c)
signal. Default value is NULL (ie dont load any context)

pathANDbasename_forcontext2save is a optional parameter. This is the path and
the base part of the filename to be used for any context files generated by the
program. Default value is /tmp/snm02.

nwgroup id a optional parameter. This helps a given set of clients and its
corresponding server to communicate with one another, independent of other
possibly parallel groups. Default value 0.

runmodes a optional parameter specifies which and all phases of the program
should be run. 1 represents mcast transfer, 2 represents ucast pi, 4 represents
ucast recovery. The values can be or'd together, if more than one phase
requires to be run. Default value is 7 (i.e run all the 3 phases).


Client's context
------------------

It contains

* list of lost packet ranges

Two context files

* When ever the program is asked to quit thro SIGINT

* At the end of mcast phase


the Logic
-----------

The 1st phase of the logic consists of mcast transfer. During this phase it
keeps track of the recieved and lost packets in sequence, as well as saving the
recieved data into corresponding location in the data file specified.

If and when it recieves a mcast stop command, it exits the mcast phase. It also
will come to know about the total blocks involved in this file/test transfer.

Next the client tries to notify any server that may be listening, about the
client's presence in the network, as well as to know who the server is. Even
thou both server and client go thro the PI phase, the logics are setup such
that a failure in PI phase doesn't impact the over all flow.

The logic goes into a unicast recovery phase, where it listens for any requests
from server about lost packets. In turn when the server requests, the client
sends the top N number of lost packet ranges it has. Parallely if it recieves
any data packets, which it didn't have before, it will save the same into the
data file. The total number of lost packet ranges and inturn the total number
of lost packets represented thro these ranges is also sent to the server as
part of the URAck packet.


Save & Resume
---------------

If one forces the program to quit when it is in the middle of a transfer, by
sending a SIGINT. Then the program irrespective of whether it is in mcast
phases or ucast phases, will save the current list of lost packets to a
predefined location.

This info can be used to resume the transfer and recover remaining or lost
packets. A simple resume logic has been added, which allows recovering when the
client was stopped in the middle of ucast phase.

ToDO: A more full fledged context requires to be saved, so that one can even
resume a mcast interruption.

NOTE: A ctrl+c will generate SIGINT if client is being run directly on a
console as the foreground process.


Server
========

The server side logic is implemented as part of two different programs.

mcast phase
-------------

The first takes care of the multicast phases.

ucast phase
-------------

The second takes care of the unicast phases. If required this unicast related
script can be called more than once, provided a context file is passed to it,
with the list of remaining clients with lost packets.

Even if the full list of know clients is passed to the 2nd invocation of the
ucast recovery program / script, the logic will handle all corner cases
properly. Because even if there are clients with fully transfered contents, if
they are running, they will inform the server that they dont have any lost
packets; and if they are not running, the server will automatically timeout wrt
such clients (the program will take more time than ideal, otherwise no other
issues).


the Context file
------------------

THis is a file used by the unicast phase server program, to get the list of
clients it should try to help wrt recovering their lost packets.

A text file having the tag <clients> in a line. Followed by lines containing
the ip addresses of the clients, one per line. Followed by </clients> in a
line.


for Firewall
--------------

The nw port usage is as follows if NwGroup is 0 (the default)

a) 1111 - Multicast Server to Clients data push
b) 1112 - Nw Broadcast PIReq from Client to Any listening Server
c) 1113 - Unicast PIAck from Server to Client

However if there are NwGroups with id/num other than 0, then use following to
identify the port to be enabled.

PortUsed = BasePort + 5*NwGroupId


Examples
==========


Example for actual testing
----------------------------

Client> ./simpnwmon02 --maddr 230.0.0.1 --local 0 10.0.2.11 --file /path/to/datafile --bcast 10.0.2.255 --contextbase /path/with/basefilename

Server> ./hkvc-nw-send-mcast.py --maddr 230.0.0.1 --file /path/to/file_to_send

Possibility1 (Prefered) ==>
Server> ./hkvc-nw-recover.py --maddr 230.0.0.1 --file /path/to/file_to_send --context /path/to/file_with_list_of_all_known_client_ips FOLLOWED_BY_IF_REQUIRED
Server> ./hkvc-nw-recover.py --maddr 230.0.0.1 --file /path/to/file_to_send --context /path/to/file_with_list_of_all_known_or_remaining_client_ips

Possibility2 ==>
Server> ./hkvc-nw-recover.py --maddr 230.0.0.1 --file /path/to/file_to_send AND_OR
Server> ./hkvc-nw-recover.py --maddr 230.0.0.1 --file /path/to/file_to_send --context /path/to/file_with_list_of_all_known_or_remaining_client_ips

If the client was force quit in the middle of a unicast phase, then to resume run the below
TO run both UCast PI and UR phases
Client> ./simpnwmon02 --maddr 230.0.0.1 --local 0 10.0.2.11 --file /path/to/datafile --bcast 10.0.2.255 --runmodes 6 --context /path/to/saved_contextfile  OR
TO run only the UCast UR phase
Client> ./simpnwmon02 --maddr 230.0.0.1 --local 0 10.0.2.11 --file /path/to/datafile --bcast 10.0.2.255 --runmodes 4 --context /path/to/saved_contextfile

The default /path/to/saved_contextfile will be /tmp/snm02.lostpackets.quit, however if --contextbase was given then updated path and name suitably.


Example for testing using VM
------------------------------

The below example assumes autogenerated testblocks are used instead of a actual file

On Client run

Client> ./simpnwmon02 0 230.0.0.1 10.0.2.11 /dev/null 10.0.2.255

On Server run, these two commands one after the other

Server> ./hkvc-nw-send-mcast.py --maddr 230.0.0.1 --testblocks 50000 --simloss

Possibility1 ==>
Server> ./hkvc-nw-recover.py --maddr 230.0.0.1 --testblocks 5000 AND_OR
Server> ./hkvc-nw-recover.py --maddr 230.0.0.1 --testblocks 5000 --context /path/to/file_with_list_of_client_ips

Possibility2 ==>
Server> ./hkvc-nw-recover.py --maddr 230.0.0.1 --testblocks 5000 --context /path/to/file_with_list_of_all_known_client_ips FOLLOWEDBY_IFREQUIRED
Server> ./hkvc-nw-recover.py --maddr 230.0.0.1 --testblocks 5000 --context /path/to/file_with_list_of_all_known_or_remaining_client_ips

If required could Use slow mode ==>
Server> ./hkvc-nw-recover.py --maddr 230.0.0.1 --testblocks 5000 --slow


If the client was force quit in the middle of unicast recovery, then to resume run the below
Client> ./simpnwmon02 0 230.0.0.1 10.0.2.11 /dev/null 10.0.2.255 /path/to/lostpacketranges_savefile

The default /path/to/lostpacketranges_savefile will be /tmp/snm02.lostpackets




Notes / Thoughts during some of the releases
#############################################

v20190115IST02XY
=================

Attached is a updated version with following main changes

a) All nw program related variables moved into a single context. And wrapper
funcs added to use this new context, as required.

b) Added a nwgroup argument, which helps have multiple parallel nw
tests/transfers running on the network, as well as wrt multiple server
instances/client instances running on a given machine. Currently this support
has been fully implemented on client side. TODO1: In next release it will be
also added to the server side logic.

TODOX:
Later MaxSeqNumSeen till a given moment will also be saved as part of this
context. And then saving and restoring of the nw context will be added. This
will allow one to implement mcast resume on the client side if required in
future.


v20190114IST1923
=================

Mainly a cleanup and fine grained control related updates wrt client logic.

The client now uses descriptive tags to identify the arguments being specified.
Running the client without arguments will give the details. A sample client run
will be

./simpnwmon02 --maddr 230.0.0.1 --local 0 10.0.2.11 --file /path/to/datafile --bcast 10.0.2.255 --contextbase /path/to/contextfilebasename

For some reason if client was stopped in the middle of unicast recovery then to
resume within ucast recovery run

./simpnwmon02 --maddr 230.0.0.1 --local 0 10.0.2.11 --file /path/to/datafile --bcast 10.0.2.255 --context /path/to/saved_contextfile --runmodes 4

NOTE: that normal running requires --contextbase, while resuming requires
--context. Also resuming requires --runmodes 6 (if server still in PI phase) or
--runmodes 4 (if server already in UR phase or even if in PI phase, this will
always work).

Also when done with mcast, now it saves a lost packet ranges context file. This
is independent of the quit related lost packet ranges context file, which will
be created if the program is forced to quit with a SIGINT.

Just to be clear:

If for some reason one had to stop the client in the middle of unicast recovery
by sending it a SIGINT. Then while resuming it

Irrespective of whether the server is in unicast PI phase or unicast UR phase,
the client can be resumed with --runmodes 6 or --runmodes 4, and everything
will work fine.

However if we want to resume and resync in a efficient manner then

If server in ucast PI phase, then start client with --runmodes 6
if server in ucast UR phase already, then start client with --runmodes 4


v20181228
===========

There is some odd holes seen in the data file after both mcast and ucast are
finished successfully. Need to cross-check this later.

Tried changing from FileOutputStream to RandomAccessFile in-case if its that
FileOutputStream doesn't allow selective writing into a existing file, but that
doesnt seem to have solved it, need to test the RandomAccessFile after removing
the data.bin file on the target and see how a fresh transfer with
RandomAccessFile works out.

Also on testing on a actual physical android target, found that if the packet
data size is at something like 8 bytes or so, the Android Java based GUI is
picking up the packets, but if I increase the data size to 32 or above, it
doesn't seem to be recieving the packets.

v20181225+
==========

The nw port usage is as follows

a) 1111 - Multicast Server to Clients data push
b) 1112 - Nw Broadcast PIReq from Client to Any listening Server
c) 1113 - Unicast PIAck from Server to Client


So if using Android AVD for testing remember to redir both 1111 as well as 1113

i.e telnet localhost 5554
NOTE: assuming it is the 1st avd started
auth value_required_to_authenticate
NOTE: got from .emulator.... file in the users home dir
redir add udp:1111:1111
redir add udp:1113:1113
redir list

Also if using AVD, then in GUI remember to set the PIInitialAddr to 10.0.2.255
in the given unicast related edittext.



v20181223
===========

Data Thread synchronisation
------------------------------

* Failure - UseData before FillData
Producer->Acquire->FillData->Loop
Consumer->UseData->Release->Loop

* Failure - Race, FillData before UseData is finished
Producer->FillData->Acquire->Loop
Consumer->Release->UseData->Loop

3Locks&Buffers
1,2,3,0-1
0,0,0,1=XXXXXX

* Ok - SemCount 1 or more less than Total Buffers
Producer->FillData->Acquire->Loop
Consumer->Release->UseData->Loop

3B(2L)
1-1,2-2,3-1,
0-0,1-1,2-2,

B1-L1,B2-L2,B3-L1
L0-B0,L0-B0,L1-B1

But will require dummy producing to flush out data in deltaOf(buf-lock) buffers
at the end, when actual producing is done.

TODO
-------

01) Currently Data is copied from a fixed buffer in AsyncTask to the data
buffer in DataHandler, avoid this and use the data buffer in DataHandler
directly.

02) Currently only a predefined (set to 1 currently) monitored channel is
logged as well as its data saved.

However if required Update the Logging and Data saving logic to work across
multiple channels.  i.e Each channels log and data should be saved to seperate
log and data files.

03) There is a issue with the 1st packet with seq number 0 being considred as a
olderSeqs, fix this corner case.

04) Add logic to use unicast to recover the packets lost during multicast.


v20181220
===========

hkvc-nw-test script new argument

--file file_to_send

Target java.net.multicast logic

Now it logs lost packets into lost.log file in the applications' directory on
external storage


v20181207IST1005
=================
hkvc-nw-test script arguments

--Bps 2000000 will set the throughput to 2M bytes per second

--datasize 1024 will set the packet size to 1K. The actual packet will be
4bytes+1K, where the 4 bytes correspond to 32bit seqNum in little-endian
format.

--dim 17, tells as to after how many packets are sent the throttling delay if
any should be applied.

--port 1111, tells that udp packets should be sent to port 1111

by default the logic is programmed to send packets to 127.0.0.1. By changing it
to a multicast ip address, one should be able to send to multicast groups
ideally. Have to cross-check the multicast packet sending requirements once,
but I feel that we dont require any special settting of socket for sending
multicast packets, while reception will require joining of the multicast group.
If this vague remembering of multicast behaviour that I have is correct, then
just changing the address in the program will allow using of this simple
pythong script to test multicast transfer behaviour to some extent.


v20181204
============

Now If only one mcast channel is being monitored, then it assumes that it could
be a high throughtput channel, so it will update the progress wrt monitoring in
the gui, only once every 10 iterations thro the monitoring loop.

However if more than 1 channel is being monitored at the same time, then as the
program currently doesn't provide a efficient way of handling this case, it
assumes that the channels are not high througput ones, and or the user is not
interested in getting accurate detailed monitored info like num of disjoint
seqNums noticied or num of times the seqNum jumped backwards etc. So it updates
the progress of monitoring in the GUI for each iteration thro the monitoring
loop.


v20181202
============

TODO1:

Verify if any buffering occurs if lot of packets are recieved on a given
channel.  Because in a given loop I read only 1 packet from a given channel and
wait for timeout or reception (again read only 1 packet, even if more are
there) of data on other channels.

And see the impact of the same practically.

NOTE1:

Supports max of 10 MCast channels i.e MCastGroupIP+Port.
It waits for upto 50msecs before timing out wrt each channel being monitored.
So if there are 10 channels being monitored and 9 of them don't have any data
then it will take 450+timeToReadDataFromTheSingleChannelWIthData msecs for 
each packet of data read from the alive channel.

So this will work for monitoring upto 10 channels with activitiy of 1 or 2
packets per second.

However if the data throughput is heavy, then monitor that single channel only 
to avoid lossing data packets due to overflow wrt buffers allocated by kernel
for the channel.

NOTE2:

ONe can specify different delay counts wrt when to treat delay in data activity
on a channel to be critical to mark it red. If only 1 channel is monitored,
then the delay count corresponds to delaycount*50msec of delay. However if more
than 1 channel is monitored, then the delay count to time mapping is more
complicated and dependent on data activity in realtime across all those
channels. Rather the delaycount can be treated as how many times the
applications checked to see if there is any data for a given channel and then
timedout.

TODO2: If I account timeout wrt other channels also, for each given channel,
then the delay count mirrors the actual time lost more accurately, and the 
delaycount*50msec can still be valid to a great extent. However the current
logic doesn't do this. Also this logic would assume that any channel which
reads data instead of leading to a timeout, will read the data at a very fast
rate which is in the vicinity of within a msec or so. Else the delta between
the actual delaycount based time calculation and real wall clock time will
increase.

